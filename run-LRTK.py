import os, sys, gzip
import getopt
import time
import re
import subprocess
import random
import string

def LRTK_usage(_Command1_, _Command2_ = "0"):
	helpinfo = dict()
	subhelpinfo = dict()

	usage_all = \
	'''

	LRTK: Linked Reads ToolKit, a toolkit for 10X genomic data analysis,including Quality control , Resequencing analysis and De novo assembly
	Version: 1.0.0
	Dependents: Python (>=3.0), BWA, Picard (>=2.9), java (>=1.8), SAMtools, GATK (>= 3.0)
	Last Updated Date: 2017-06-01
	Contact: meijp@foxmail.com

	Usage: python LRTK.py <command> [options]

	Command:        
                        Config     Generate configuration file
                        QCall      Execute the whole pipeline of quality control
                        Reseqall   Execute the whole pipeline of resequencing
                        Denovoall  Execute the whole pipeline of de novo assembly
                                                
                        QC         Execute selected steps for quality control 
                        Reseq      Execute selected steps for resequencing
                        Denovo     Execute selected steps for de novo assembly

	
	Note: LRTK is allowed to modify configure file to include customerized parameters and datasets.

	'''
	helpinfo["N"] = usage_all

	QCall_options = \
	'''

	-i --input, the input file containing fastq information (The input file contains three columns:1.Sample ID;2.Library ID;3. Path to sample fastqs).
	-o --outputdir, the path to output
	-p --parallel, the number of CPU allowed to use (default: 1)

	'''
	helpinfo["QCall"] = QCall_options

	QC_options = \
	'''

	CFQ     generate clean fastq files and correct barcode error
 	ALN     reads alignment by BWA (must complete CFQ)
 	MARK     merge all bam files belong to the same sample and barcode aware PCR duplication removal (must complete ALN)
 	STAT    calculate QC statistics, including Cf, Cr, MuFL, NFP etc. (must complete CFQ and ALN)

	'''
	helpinfo["QC"] = QC_options

	CFQ_options = \
	'''

	-i --input, the input file containing fastq information (The input file contains three columns:1.Sample ID;2.Library ID;3. Path to sample fastqs).
	-o --outputdir, the path to output
	-p --parallel, the number of CPU allowed to use (default: 1)
	'''
	subhelpinfo["CFQ"] = CFQ_options

	ALN_options = \
	'''
	-i --input, the input file containing the clean fastqs generated by CFQ and sample infomation (The input file contains four columns:1.Sample ID;2.Library ID;3.Path to read1 clean fastqs;4.Path to read2 clean fastqs).
	-o --outputdir, the path to output
	-p --parallel, the number of CPU allowed to use [default: 1]
	'''
	subhelpinfo["ALN"] = ALN_options

	MAK_options = \
	'''
	-i --input, the input file containing the information of bam files (The input file contains two columns:1.Sample Id;2.Path to bam)
	-o --outputdir, the path to output
	-p --parallele, the number of CPU allowed to use [default: 1]
	'''
	subhelpinfo["MARK"] = MAK_options

	STAT_options = \
	'''
	-i --input, the input path that contains the SAM/BAM files generated by ALN
	-o --outputdir, the path to output
	'''
	subhelpinfo["STAT"] = STAT_options

	Reseqall_options = \
	'''
	-i --input, the input path that contains the BAM files generated by QCall or ALN
	-o --outputdir, the path to output
	-L, --chrlist, list of chromosome (e.g. chr1, chr2, chrX)
	-p, --parallel, the number of CPU allowed to use [default: 1]
	'''
	helpinfo["Reseqall"] = Reseqall_options

	Reseq_options = \
	'''
	Varcall     call SNVs and Indels by GATK
	SVcall      call structure variantion by GROC-SVs
	Phasing     phasing variants by HapCUT2
	'''
	helpinfo["Reseq"] = Reseq_options

	Varcall_options = \
	'''
	-i, --input, the input path that contains the BAM files generated by QCall or ALN
	-o, --outputdir, the output directory path
	-L, --chrlist, list of chromosomes (e.g.chr1,chr2,chrX)
	-p, --parallel, the number of CPU allowed to use [default: 1]
	'''
	subhelpinfo["Varcall"] = Varcall_options

	SVcall_options = \
	'''
	-i --input, the input path that contains the BAM files generated by QCall or ALN
	-o --outputdir, the path to output
	'''
	subhelpinfo["SVcall"] = SVcall_options

	Phasing_options = \
	'''
	-i --input, the input path that contains the BAM files generated by QCall or ALN
	-v --vcf, unphased vcf file generated by Varcall or the other variant callers, both compressed or uncompressed vcf files are allowed
	-o --outputdir, the path to output
	'''
	subhelpinfo["Phasing"] = Phasing_options

	Denovoall_options = \
	'''
	-i --input, the input path
	-o --outputdir, the path to output
	'''
	helpinfo["Denovoall"] = Denovoall_options

	Denovo_options = \
	'''

	'''

	if _Command1_ in helpinfo:
		if _Command2_ in subhelpinfo:
			print (subhelpinfo[_Command2_])
		else:
			print (helpinfo[_Command1_])
	else:
		print (helpinfo["N"])
	sys.exit(1)

def run_parallel(shell_file, maxnum):
	rshell_file = open(shell_file, 'r')
	shell_list = list()
	for shf in rshell_file:
		shf = shf.strip()
		shell_list.append(shf)
	finishNum = 0
	pn = 0
	ts = 0
	Shell_Num = len(shell_list)
	maxnum = int(maxnum)
	shell_line = None
	shelldir = os.path.dirname(shell_file) + "/tmp"
	if os.path.isdir(shelldir):
		pass
	else:
		os.mkdir(shelldir)
	while finishNum < Shell_Num:
		if pn < maxnum:
			if pn == 0:
				tmpshell = os.path.join(shelldir, "tmp." + str(ts) + ".sh")
				wtmpshell = open(tmpshell, 'w')
				shell_line = "sh " + shell_list[finishNum] + " &\n"
			else:
				shell_line = shell_line + "sh " + shell_list[finishNum] + " &\n"
			pn = pn + 1

		finishNum = finishNum + 1
		if pn == maxnum:
			shell_line = shell_line + "wait\necho Done\n"
			wtmpshell.write(shell_line)
			wtmpshell.close()
			subprocess.call(["sh", tmpshell])
			pn = 0
			ts = ts + 1
			sys.stderr.write("Command: %s\n" % shell_line)

	if pn > 0:
		tmpshell = os.path.join(shelldir, "tmp." + str(ts) + ".sh")
		wtmpshell = open(tmpshell, 'w')
		shell_line = shell_line + "wait\necho Done\n"
		wtmpshell.write(shell_line)
		wtmpshell.close()
		subprocess.call(["sh", tmpshell])
		sys.stderr.write("Command: %s\n" % shell_line)

def check_info(result, attribute):
	if attribute == "file":
		if os.path.isfile(result):
			pass
		else:
			sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), result))
			sys.exit(-1)
	elif attribute == "dir":
		if os.path.isdir(result):
			pass
		else:
			os.makedirs(result)
	elif attribute == "num":
		if re.search('\D', result):
			sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p %s \n" % result)
			sys.exit(-1)

if __name__ == '__main__':
	if len(sys.argv) == 1:
		LRTK_usage("N")
	elif len(sys.argv) == 2:
		LRTK_usage(sys.argv[1])
	elif len(sys.argv) == 3:
		LRTK_usage(sys.argv[1], sys.argv[2])

	InputFqList = None
	OutputDir = None
	ParalleleNum = 1

	CleanFqList = None

####################################################### CFQ #################################################################
	runCFQ = 0
	if sys.argv[1] == "QCall":
		runCFQ = 1
	elif sys.argv[1] == "QC" and sys.argv[2] == "CFQ":
		runCFQ = 2
	if runCFQ > 0:
		opts, args = getopt.gnu_getopt(sys.argv[runCFQ:], 'i:o:p:', ['input', 'outputdir', 'parallel'])
		for o, a in opts:
			if o == '-i' or o == '--input':
				InputFqList = a
			if o == '-o' or o == '--outputdir':
				OutputDir = a
			if o == '-p' or o == '--parallel':
				ParalleleNum = a

		if os.path.isfile(InputFqList):
			pass
		else:
			sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), InputFqList))
			sys.exit(-1)

		if os.path.isdir(OutputDir):
			pass
		else:
			os.mkdir(OutputDir)
		print(ParalleleNum)
		if re.search('\D', ParalleleNum):
			sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p\n")
			sys.exit(-1)
		else:
			if int(ParalleleNum) > 1:
				sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		ScriptDir = os.path.abspath(os.path.dirname(sys.argv[0]))
		print(ScriptDir)
		CFQ_script = ScriptDir + "/src/clean_fastq.py"
		if os.path.isfile(CFQ_script):
			pass
		else:
			sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % CFQ_script)
			sys.exit(-1)
		QC_config = OutputDir + "/QC.config"
		if os.path.isfile(QC_config):
			pass
		else:
			Create_config_script = ScriptDir + "/src/create_config.py"
			subprocess.call(["python", Create_config_script, "QC", "-o", OutputDir])

		rInputFqList = open(InputFqList, 'r')
		CleanFqList = OutputDir + "/clean_fq.txt"
		wCleanFqList = open(CleanFqList, 'w')
		randomstring = "CFQ_" + ''.join(random.sample(string.ascii_letters + string.digits, 8))
		CFQshell = OutputDir + "/" + randomstring + ".sh"
		wCFQshell = open(CFQshell, 'w')
		for fqinfo in rInputFqList:
			fqinfo = fqinfo.strip()
			(SampleId, LibraryId, FqPath) = re.split("\t", fqinfo)
			FqPathBasename = os.path.basename(FqPath)
			b = str(FqPathBasename)
			if b[(len(b)-9):] == ".fastq.gz":
				b = b[0:(len(b)-9)]
			elif b[(len(b)-6):] == ".fq.gz":
				b = b[0:(len(b)-6)]
			elif b[(len(b)-6):] == ".fastq":
				b = b[0:(len(b)-6)]
			elif b[(len(b)-3):] == ".fq":
				b = b[0:(len(b)-3)]
			FqPathBasename = b

			clean_FQ_output_dir = OutputDir + "/" + SampleId + "/" + FqPathBasename
			newFqPathBasename = FqPathBasename
			if os.path.isdir(clean_FQ_output_dir):
				pass
			else:
				os.makedirs(clean_FQ_output_dir)

			FQshell = clean_FQ_output_dir + "/CFQ." + SampleId + ".sh"
			runFQshell = FQshell + "\n"
			wCFQshell.write(runFQshell)
			wFQshell = open(FQshell, 'w')
			shell_line = " ".join(["python", CFQ_script, "-i", FqPath, "-o", clean_FQ_output_dir, "-c", QC_config, "\n"])
			wFQshell.write(shell_line)
			wFQshell.close()
			newfq1 = clean_FQ_output_dir + "/" + newFqPathBasename + "_1.fq.gz"
			newfq2 = clean_FQ_output_dir + "/" + newFqPathBasename + "_2.fq.gz"
			newinfo = "\t".join([SampleId, LibraryId, newfq1, newfq2]) + "\n"
			wCleanFqList.write(newinfo)
		wCleanFqList.close()
		wCFQshell.close()

		run_parallel(CFQshell, ParalleleNum)
		sys.stderr.write("[ %s ] new fq has been listed in %s \n\n" % (time.asctime(), CleanFqList))
####################################################### CFQ #################################################################

####################################################### ALN #################################################################
	runALN = 0
	BamFileList = None
	if sys.argv[1] == "QCall":
		runALN = 1
	elif sys.argv[1] == "QC" and sys.argv[2] == "ALN":
		runALN = 2
	if runALN > 0:
		opts, args = getopt.gnu_getopt(sys.argv[runALN:], 'i:o:p:', ['input', 'outputdir', 'parallel'])
		for o, a in opts:
			if runALN == 2:
				if o == '-i' or o == '--input':
					CleanFqList = a
			if o == '-o' or o == '--outputdir':
				OutputDir = a
			if o == '-p' or o == '--parallel':
				ParalleleNum = a

		if os.path.isfile(CleanFqList):
			pass
		else:
			sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), CleanFqList))
			sys.exit(-1)

		if os.path.isdir(OutputDir):
			pass
		else:
			os.mkdir(OutputDir)

		if re.search('\D', ParalleleNum):
			sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p\n")
			sys.exit(-1)
		else:
			if int(ParalleleNum) > 1:
				sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		ScriptDir = os.path.dirname(sys.argv[0])
		ALN_script = ScriptDir + "/src/alignment.py"
		if os.path.isfile(ALN_script):
			pass
		else:
			sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % ALN_script)
			sys.exit(-1)
		QC_config = OutputDir + "/QC.config"
		if os.path.isfile(QC_config):
			pass
		else:
			Create_config_script = ScriptDir + "/src/create_config.py"
			subprocess.call(["python", Create_config_script, "QC", "-o", OutputDir])

		rCleanFqList = open(CleanFqList, 'r')
		BamFileList = OutputDir + "/original_bam.txt"
		wBamFileList = open(BamFileList, 'w')
		randomstring = "ALN_" + ''.join(random.sample(string.ascii_letters + string.digits, 8))
		ALNshell = OutputDir + "/" + randomstring + ".sh"
		wALNshell = open(ALNshell, 'w')
		for fqinfo in rCleanFqList:
			fqinfo = fqinfo.strip()
			(SampleId, LibraryId, FqPath1, FqPath2) = re.split("\t", fqinfo)
			FqPathBasename = os.path.basename(FqPath1)
			FqPathBasename = FqPathBasename.replace("_1.fq.gz", '')

			Fqprefix = FqPath1.replace("_1.fq.gz", '')

			BAM_output_dir = OutputDir + "/" + SampleId + "/" + FqPathBasename
			if os.path.isdir(BAM_output_dir):
				pass
			else:
				os.makedirs(BAM_output_dir)

			RGinfo = "'@RG\\tID:" + LibraryId + "\\tPL:10x\\tPU:" + FqPathBasename + "\\tLB:" + LibraryId + "\\tSM:" + SampleId + "'"

			BAMshell = BAM_output_dir + "/ALN." + SampleId + ".sh"
			runBAMshell = BAMshell + "\n"
			wALNshell.write(runBAMshell)
			wBAMshell = open(BAMshell, 'w')
			shell_line = " ".join(["python", ALN_script, "-i", Fqprefix, "-o", BAM_output_dir, "-r", RGinfo, "-c", QC_config, "\n"])
			wBAMshell.write(shell_line)
			wBAMshell.close()
			bam = Fqprefix + ".sorted.bam"
			baminfo = "\t".join([SampleId, bam]) + "\n"
			wBamFileList.write(baminfo)
		rCleanFqList.close()
		wBamFileList.close()
		wALNshell.close()

		run_parallel(ALNshell, ParalleleNum)
		sys.stderr.write("[ %s ] bam files have been listed in %s \n\n" % (time.asctime(), BamFileList))
####################################################### ALN #################################################################

####################################################### MAK #################################################################
	runMAK = 0
	MarkBamFileList = None
	if sys.argv[1] == "QCall":
		runMAK = 1
	elif sys.argv[1] == "QC" and sys.argv[2] == "MAK":
		runMAK = 2
	if runMAK > 0:
		opts, args = getopt.gnu_getopt(sys.argv[runMAK:], 'i:o:p:', ['input', 'outputdir', 'parallel'])
		for o, a in opts:
			if runMAK == 2:
				if o == '-i' or o == '--input':
					BamFileList = a
			if o == '-o' or o == '--outputdir':
				OutputDir = a
			if o == '-p' or o == '--parallel':
				ParalleleNum = a

		if os.path.isfile(BamFileList):
			pass
		else:
			sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), BamFileList))
			sys.exit(-1)

		if os.path.isdir(OutputDir):
			pass
		else:
			os.mkdir(OutputDir)

		if re.search('\D', ParalleleNum):
			sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p\n")
			sys.exit(-1)
		else:
			if int(ParalleleNum) > 1:
				sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		ScriptDir = os.path.dirname(sys.argv[0])
		MAK_script = ScriptDir + "/src/mergeMark_bam.py"
		if os.path.isfile(MAK_script):
			pass
		else:
			sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % ALN_script)
			sys.exit(-1)
		QC_config = OutputDir + "/QC.config"
		if os.path.isfile(QC_config):
			pass
		else:
			Create_config_script = ScriptDir + "/src/create_config.py"
			subprocess.call(["python", Create_config_script, "QC", "-o", OutputDir])

		bamDict = dict()
		rBamFileList = open(BamFileList, 'r')
		for eachBamfile in rBamFileList:
			eachBamfile = eachBamfile.strip()
			(SampleId, bamfile) = re.split("\t", eachBamfile)
			if SampleId in bamDict:
				bamDict[SampleId] = bamDict[SampleId] + "\n" + bamfile
			else:
				bamDict[SampleId] = bamfile
		rBamFileList.close()

		MAKshell = OutputDir + "/MAK_" + ''.join(random.sample(string.ascii_letters + string.digits, 8)) + ".sh"
		wMAKshell = open(MAKshell, 'w')
		MarkBamFileList = OutputDir + "/merge_marked_bam.txt"
		wMarkBamFileList = open(MarkBamFileList, 'w')
		for samplekey in bamDict.keys():
			sample_bam = OutputDir + "/" + SampleId + "/bam.txt"
			wbam = open(sample_bam, 'w')
			allbam = bamDict[samplekey] + "\n"
			wbam.write(allbam)
			wbam.close()

			BAMshell = OutputDir + "/" + samplekey + "/merge_mark_bam.sh"
			runBAMshell = BAMshell + "\n"
			wMAKshell.write(runBAMshell)

			wBAMshell = open(BAMshell, 'w')
			shell_line = " ".join(["python", MAK_script, "-i", sample_bam, "-o", OutputDir + "/" + samplekey + "/" + samplekey + ".sorted.merged.marked.bam", "-c", QC_config, "\n"])
			wBAMshell.write(shell_line)
			wBAMshell.close()
			markedbam = OutputDir + "/" + samplekey + "/" + samplekey + ".sorted.merged.marked.bam"
			baminfo = "\t".join([SampleId, markedbam]) + "\n"
			wMarkBamFileList.write(baminfo)
		wMAKshell.close()
		wMarkBamFileList.close()

		run_parallel(MAKshell, ParalleleNum)
		sys.stderr.write("[ %s ] merged and duplication marked bam files have been listed in %s \n\n" % (time.asctime(), MarkBamFileList))
####################################################### MAK #################################################################

####################################################### STAT ################################################################
	UnphasedVcfList = None
	runSTAT = 0
	if sys.argv[1] == "QCall":
		runSTAT = 1
	elif sys.argv[1] == "QC" and sys.argv[2] == "STAT":
		runSTAT = 2
	if runSTAT > 0:
		 opts, args = getopt.gnu_getopt(sys.argv[runSTAT:], 'i:o:p:', ['input', 'outputdir', 'parallel'])
		 for o, a in opts:
		 	if runSTAT == 2:
			 	if o == '-i' or o == '--input':
			 		MarkBamFileList = a
		 	if o == '-o' or o == '--outputdir':
		 		OutputDir = a
		 	if o == '-p' or o == '--parallel':
		 		ParalleleNum = a

		 if os.path.isfile(MarkBamFileList):
		 	pass
		 else:
		 	sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), MarkBamFileList))
		 	sys.exit(-1)

		 if os.path.isdir(OutputDir):
		 	pass
		 else:
		 	os.mkdir(OutputDir)

		 if re.search('\D', ParalleleNum):
		 	sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p\n")
		 	sys.exit(-1)
		 else:
		 	if int(ParalleleNum) > 1:
		 		sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		 ScriptDir = os.path.dirname(sys.argv[0])
		 STAT_script = ScriptDir + "/src/calculate.py"
		 if os.path.isfile(STAT_script):
		 	pass
		 else:
		 	sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % STAT_script)
		 	sys.exit(-1)
		 QC_config = OutputDir + "/QC.config"
		 if os.path.isfile(QC_config):
		 	pass
		 else:
		 	Create_config_script = ScriptDir + "/src/generate_config.py"
		 	subprocess.call(["python", Create_config_script, "QC", "-o", OutputDir])

		 rMarkBamFileList = open(MarkBamFileList, 'r')
		 STATshell = OutputDir + "/STAT_" + ''.join(random.sample(string.ascii_letters + string.digits, 8)) + ".sh"
		 wSTATshell = open(STATshell, 'w')
		 for eachBamfile in rMarkBamFileList:
		 	eachBamfile = eachBamfile.strip()
		 	(SampleId, bamfile) = re.split("\t", eachBamfile)

		 	Eachshell = OutputDir + "/" + SampleId + "/stat.sh"
		 	runEachshell = Eachshell + "\n"
		 	wSTATshell.write(runEachshell)

		 	wEachshell = open(Eachshell, 'w')
		 	shell_line = " ".join(["python", STAT_script, "-i", bamfile, "-o", OutputDir + "/" + SampleId, "-c", QC_config, "\n"])
		 	wEachshell.write(shell_line)
		 	wEachshell.close()
		 rMarkBamFileList.close()
		 wSTATshell.close()

		 run_parallel(STATshell, ParalleleNum)
		 sys.stderr.write("[ %s ] calculation of CF&CR has finished!\n\n" % time.asctime())
####################################################### STAT ################################################################

####################################################### Varcall #############################################################
	runVAR = 0
	if sys.argv[1] == "Reseqall":
		runVAR = 1
	elif sys.argv[1] == "Reseq" and sys.argv[2] == "Varcall":
		runVAR = 2
	if runVAR > 0:

		all_command = " ".join(sys.argv)
		sys.stderr.write("Command:\t%s\n\n" % all_command)

		opts, args = getopt.gnu_getopt(sys.argv[runCFQ:], 'i:o:L:p:', ['input', 'outputdir', '--chrlist', 'parallel'])
		for o, a in opts:
			if o == '-i' or o == '--input':
				MarkBamFileList = a
			if o == '-o' or o == '--outputdir':
				OutputDir = a
			if o == '-L' or o == '--chrlist':
				Chrlist = a
			if o == '-p' or o == '--parallel':
				ParalleleNum = a

		if os.path.isfile(MarkBamFileList):
			pass
		else:
			sys.stderr.write("[ %s ] %s does not exist!\n" % (time.asctime(), MarkBamFileList))
			sys.exit(-1)

		if os.path.isdir(OutputDir):
			pass
		else:
			os.mkdir(OutputDir)

		if re.search('\D', str(ParalleleNum)):
			sys.stderr.write("Error: string was found for parallel number, only number is accepted for -p\n")
			sys.exit(-1)
		else:
			if int(ParalleleNum) > 1:
				sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		ScriptDir = os.path.dirname(sys.argv[0])
		VAR_script = ScriptDir + "/src/SnpInDel_call.py"
		if os.path.isfile(VAR_script):
			pass
		else:
			sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % VAR_script)
			sys.exit(-1)
		Reseq_config = OutputDir + "/Reseq.config"
		if os.path.isfile(Reseq_config):
			pass
		else:
			Create_config_script = ScriptDir + "/src/create_config.py"
			subprocess.call(["python", Create_config_script, "Reseq", "-o", OutputDir])

		UnphasedVcfList = OutputDir + "/unphased.vcf.txt"
		wUnphasedVcfList = open(UnphasedVcfList, 'w')
		rMarkBamFileList = open(MarkBamFileList, 'r')
		VARshell = OutputDir + "/VAR_" + ''.join(random.sample(string.ascii_letters + string.digits, 8)) + ".sh"
		wVARshell = open(VARshell, 'w')
		for eachBamfile in rMarkBamFileList:
			eachBamfile = eachBamfile.strip()
			(SampleId, bamfile) = re.split("\t", eachBamfile)

			SampleDir = OutputDir + "/" + SampleId
			if os.path.isdir(SampleDir):
				pass
			else:
				os.makedirs(SampleDir)

			Eachshell = OutputDir + "/" + SampleId + "/variant_call.sh"
			runEachshell = Eachshell + "\n"
			wVARshell.write(runEachshell)

			wEachshell = open(Eachshell, 'w')
			shell_line = " ".join(["python", VAR_script, "-i", bamfile, "-o", SampleDir, "-c", Reseq_config, "-L", Chrlist, "\n"])
			wEachshell.write(shell_line)
			wEachshell.close()
			unphased_vcf = SampleDir + "/vcf/all.vcf\n"
			wUnphasedVcfList.write(unphased_vcf)
		rMarkBamFileList.close()
		wVARshell.close()
		wUnphasedVcfList.close()

		run_parallel(VARshell, ParalleleNum)
		sys.stderr.write("[ %s ] Variation call has finished!\n\n" % time.asctime())
####################################################### Varcall #############################################################

####################################################### Phasing #############################################################
	runPHASE = 0
	if sys.argv[1] == "Reseqall":
		runPHASE = 1
	elif sys.argv[1] == "Reseq" and sys.argv[2] == "Phasing":
		runPHASE = 2
	if runPHASE > 0:
		opts, args = getopt.gnu_getopt(sys.argv[runPHASE:], 'i:o:p:v:', ['input', 'outputdir', 'vcf', 'parallel'])
		for o, a in opts:
			if runPHASE == 2:
				if o == '-v' or o == '--vcf':
					UnphasedVcfList = a
			if o == 'i' or o == '--input':
				MarkBamFileList = a
			if o == '-o' or o == '--outputdir':
				OutputDir = a
			if o == '-p' or o == '--parallel':
				ParalleleNum = a

		check_info(MarkBamFileList, "file")
		check_info(UnphasedVcfList, "file")
		check_info(OutputDir, "dir")
		check_info(ParalleleNum, "num")

		if int(ParalleleNum) > 1:
			sys.stderr.write("The maximum number of %s CPUs would be invoked at the same time\n" % ParalleleNum)

		ScriptDir = os.path.dirname(sys.argv[0])
		PHA_script = ScriptDir + "/src/phasing.py"
		if os.path.isfile(PHA_script):
			pass
		else:
			sys.stderr.write("%s does not exist, the software package might not been downloaded perfectly!" % PHA_script)
			sys.exit(-1)
		Reseq_config = OutputDir + "/Reseq.config"
		if os.path.isfile(Reseq_config):
			pass
		else:
			Create_config_script = ScriptDir + "/src/create_config.py"
			subprocess.call(["python", Create_config_script, "Reseq", "-o", OutputDir])

		rMarkBamFileList = open(MarkBamFileList, 'r')
		BamDict = dict()
		rUnphasedVcfList = open(UnphasedVcfList, 'r')
		VcfDict = dict()
		for eachBamfile in rMarkBamFileList:
			eachBamfile = eachBamfile.strip()
			(SampleId, bamfile) = re.split("\t", eachBamfile)
			BamDict[SampleId] = bamfile
		for eachVcffile in rUnphasedVcfList:
			eachVcffile = eachVcffile.strip()
			(SampleId, vcffile) = re.split("\t", eachVcffile)
			VcfDict[SampleId] = vcffile
		rMarkBamFileList.close()
		rUnphasedVcfList.close()

		PHASEshell = OutputDir + "/PHASE_" + ''.join(random.sample(string.ascii_letters + string.digits, 8)) + ".sh"
		wPHASEshell = open(PHASEshell, 'w')
		phaseVcfList = OutputDir + "/phased.vcf.txt"
		wphaseVcfList = open(phaseVcfList, 'w')
		for SampleId in BamDict.keys():
			if SampleId not in VcfDict:
				sys.stderr.write("vcf file not found: %s !\n" % SampleId)
			else:
				bamfile = BamDict[SampleId]
				unphasevcffile = VcfDict[SampleId]
				sampledir = OutputDir + "/" + SampleId + "/" + "phase"
				if os.paht.isdir(sampledir):
					pass
				else:
					os.makedirs(sampledir)
				Eachshell = sampledir + "/phase.sh"
				runEachshell = Eachshell + "\n"
				wPHASEshell.write(runEachshell)

				wEachshell = open(Eachshell, 'w')
				shell_line = " ".join(["python", PHA_script, "-i", bamfile, "-v", unphasevcffile, "-o", sampledir, "-c", Reseq_config, "\n"])
				wEachshell.write(wEachshell)
				wEachshell.close()

				phasevcffile = None
				vcfname = os.path.basename(unphasevcffile)
				if vcfname.endswith('.gz'):
					b = str(vcfname)
					vcfname = b[0:(len(b)-3)]
				if vcfname.endswith(".vcf"):
					b = str(vcfname)
					phasevcffile = sampledir + "/" + b[0:(len(b)-4)] + ".phased.vcf"
				else:
					phasevcffile = sampledir + "/" + vcfname + ".phased.vcf"
				phasevcffile = SampleId + "\t" + phasevcffile + "\n"
				wphaseVcfList.write(phasevcffile)
		wPHASEshell.close()
		wphaseVcfList.close()

		run_parallel(PHASEshell, ParalleleNum)
		sys.stderr.write("[ %s ] Phasing has finished!\n\n" % time.asctime())
####################################################### Phasing #############################################################
